name: SharePoint â†’ Telegram

# Run every 10 minutes + allow manual dispatch
on:
  schedule:
    - cron: '*/10 * * * *'
  workflow_dispatch:

jobs:
  notify:
    runs-on: ubuntu-latest

    steps:
      # 1) pull your code
      - name: Check out repository
        uses: actions/checkout@v3

      # 2) fetch items & post to Telegram
      - name: Fetch SP items & notify Telegram
        env:
          AZURE_CLIENT_ID:     ${{ secrets.AZURE_CLIENT_ID }}
          AZURE_TENANT_ID:     ${{ secrets.AZURE_TENANT_ID }}
          AZURE_CLIENT_SECRET: ${{ secrets.AZURE_CLIENT_SECRET }}
          SITE_ID:             ${{ secrets.SITE_ID }}
          LIST_ID:             ${{ secrets.LIST_ID }}
          BOT_TOKEN:           ${{ secrets.BOT_TOKEN }}
          CHAT_ID:             ${{ secrets.CHAT_ID }}
        run: |
          set -euo pipefail
          echo "ðŸ”§ Installing Python packages..."
          pip install --user msal requests

          python3 - << 'EOF'
          import os, json, time, msal, requests, pathlib

          # â€” AUTH with Azure AD â€”
          app = msal.ConfidentialClientApplication(
            os.environ['AZURE_CLIENT_ID'],
            authority=f"https://login.microsoftonline.com/{os.environ['AZURE_TENANT_ID']}",
            client_credential=os.environ['AZURE_CLIENT_SECRET']
          )
          token_resp = app.acquire_token_for_client(["https://graph.microsoft.com/.default"])
          if "access_token" not in token_resp:
              print("âŒ Azure auth failed:", json.dumps(token_resp, indent=2))
              exit(1)
          token = token_resp["access_token"]

          # â€” BUILD Graph URL (correct ordering) â€”
          site = os.environ['SITE_ID']
          lst  = os.environ['LIST_ID']
          url = (
            f"https://graph.microsoft.com/v1.0/sites/{site}"
            f"/lists/{lst}/items"
            f"?$expand=fields"
            f"&$orderby=createdDateTime desc"
          )
          print("âž¡ï¸ Fetching:", url)

          # â€” LOAD last timestamp (default: 1 hour ago) â€”
          state_file = pathlib.Path("last_state.json")
          last = int(time.time()) - 3600
          if state_file.exists():
              last = json.loads(state_file.read_text()).get("last", last)

          # â€” FETCH & LOOP â€”
          resp = requests.get(url, headers={"Authorization": f"Bearer {token}"})
          resp.raise_for_status()
          items = resp.json().get("value", [])
          print(f"ðŸ”¢ Received {len(items)} items")

          new_last = last
          for idx, itm in enumerate(items, start=1):
              dt = itm.get("fields", {}).get("CreatedDateTime") or itm.get("createdDateTime") or itm.get("fields", {}).get("createdDateTime")
              print(f"ðŸ”„ Loop #{idx} â€” id={itm.get('id')} createdDateTime={dt}")
              if not dt:
                  print("   â†³ SKIP (no createdDateTime)")
                  continue

              ts = int(time.mktime(time.strptime(dt, "%Y-%m-%dT%H:%M:%SZ")))
              print(f"   â†³ parsed ts={ts}, last={last}")
              if ts <= last:
                  print("   â†³ BREAK (already processed)")
                  break

              title = itm.get("fields", {}).get("Title", "<no title>")
              link  = itm.get("webUrl")
              print(f"   â†³ SENDING message: {title}")
              p = requests.post(
                f"https://api.telegram.org/bot{os.environ['BOT_TOKEN']}/sendMessage",
                json={
                  "chat_id": os.environ['CHAT_ID'],
                  "parse_mode": "Markdown",
                  "text": f"*{title}*\n{link}"
                }
              )
              p.raise_for_status()
              new_last = max(new_last, ts)
              print(f"   â†³ new_last updated to {new_last}")

          # â€” SAVE state â€”
          state_file.write_text(json.dumps({"last": new_last}))
          EOF
